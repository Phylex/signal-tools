"""
Module containing various functions that relate to folding two discrete
complex functions
"""
from copy import copy


def fold(x: list[complex], y: list[complex]) -> list[complex]:
    """
    Performs a folding operation on two discrete, bounded, complex signals.

    Performs the folding operation. Zero padds signals such that the dimensions
    fit. The index for the signal is taken from the index in the array and
    starts at 0.
    """
    maxind = max(len(x), len(y))
    result = []
    for i in range(maxind):
        intermediate = []
        for j in range(maxind):
            try:
                xi = x[i]
            except IndexError:
                xi = 0
            try:
                yi = y[i-j]
            except IndexError:
                yi = 0
            intermediate.append(xi * yi)
        result.append(sum(intermediate))
    return result


def prepare_signals(x: list[complex],
                    y: list[complex]) -> tuple[list[complex], list[complex]]:
    """
    Prepare two signals of arbitrary length so that they have the proper shape
    to be folded

    :return: Tuple of the signals, zero padded so that they can be propely
        folded.
    :rtype: tuple containing the padded x signal at index 0 and padded y signal
        at index 1
    """
    domain_size = len(x) + len(y) - 1
    x_ = copy(x)
    for _ in range(domain_size - len(x_)):
        x_.append(0j)
    y_ = copy(y)
    for _ in range(domain_size - len(y_)):
        y_.append(0j)
    return x_, y_


def ffold(px: list[complex], py: list[complex]) -> list[complex]:
    """
    Fold two signals x(n) = \\sum_i x(i)*y(n-i)

    A more compact fold using the prepared arrays of the same size, as
    generated by `prepare_signals`.

    :return: The array containing the result of folding both signals. Same
        dimension as input signals
    :rtype: Returns a list containing complex or real floating point numbers
    """
    assert len(px) == len(py)
    domain_size = len(px)
    return [sum([px[j % domain_size] * py[(i-j) % domain_size]
                 for j in range(domain_size)]) for i in range(domain_size)]


def dirac(pos: int, length: int) -> list[complex]:
    """
    generate a dirac signal of a given length where the dirac pulse appears at index `pos`

    :param pos: index (position of the peak) in the signal
    :type pos: int, required
    :param length: length of the signal given as number of measurements
    :type length: int, required
    :return: signal of length `length` with a pulse of heigth 1 at index `pos`
    :rtype: list[complex]
    """
    assert 0 < pos <= length
    signal = [0j] * length
    signal[pos] = (1+0j)
    return signal
